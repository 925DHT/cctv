const IP_SOURCE_URL = "https://raw.githubusercontent.com/ethgan/yxip/main/ip.txt";
const KV_KEY = "best_ips";
const NODE_COUNT = 20;

async function fetchIPs() {
  const resp = await fetch(IP_SOURCE_URL, { cf: { cacheTtl: 60 } });
  if (!resp.ok) throw new Error("Failed to fetch IPs: Status " + resp.status);
  const text = await resp.text();
  return text
    .split("\n")
    .map(line => line.trim())
    .filter(ip => ip && /^\d+\.\d+\.\d+\.\d+$/.test(ip))
    .slice(0, NODE_COUNT);
}

function genClashNodes(ips) {
  return ips.map((ip, idx) => ({
    name: `优选${idx + 1}`,
    type: "ss",
    server: ip,
    port: 443,
    cipher: "aes-128-gcm",
    password: "openclash",
    plugin: "v2ray-plugin",
    "plugin-opts": {
      mode: "websocket",
      tls: true,
      host: "www.netflix.com"
    }
  }));
}

function genClashConfig(nodes) {
  const proxies = nodes.map(node =>
    "  - " +
    JSON.stringify(node)
      .replace(/"([^"]+)":/g, "$1:") // YAML 风格
      .replace(/^{/, "")
      .replace(/}$/, "")
      .replace(/,/g, "\n    ")
  ).join("\n");

  const proxyNames = nodes.map((_, i) => `      - 优选${i + 1}`).join("\n");

  // 完整配置模板：包括 version 字段和注释
  return [
    "# Clash Config Generated by Cloudflare Workers",
    "# Update: " + new Date().toISOString(),
    "version: 2.1.0",
    "",
    "port: 7890",
    "socks-port: 7891",
    "allow-lan: true",
    "mode: Rule",
    "log-level: info",
    "external-controller: '127.0.0.1:9090'",
    "",
    "proxies:",
    proxies,
    "",
    "proxy-groups:",
    "  - name: \"自动选择\"",
    "    type: url-test",
    "    proxies:",
    proxyNames,
    "    url: 'http://www.gstatic.com/generate_204'",
    "    interval: 300",
    "  - name: \"手动切换\"",
    "    type: select",
    "    proxies:",
    proxyNames,
    "  - name: \"Netflix\"",
    "    type: select",
    "    proxies:",
    "      - 自动选择",
    proxyNames,
    "  - name: \"YouTube\"",
    "    type: select",
    "    proxies:",
    "      - 自动选择",
    proxyNames,
    "  - name: \"Telegram\"",
    "    type: select",
    "    proxies:",
    "      - 自动选择",
    proxyNames,
    "  - name: \"OpenAI\"",
    "    type: select",
    "    proxies:",
    "      - 自动选择",
    proxyNames,
    "  - name: \"国外流量\"",
    "    type: select",
    "    proxies:",
    "      - 自动选择",
    proxyNames,
    "  - name: \"国内流量\"",
    "    type: select",
    "    proxies:",
    "      - DIRECT",
    "",
    "rules:",
    // 流媒体及常见应用分流
    "  - DOMAIN-SUFFIX,netflix.com,Netflix",
    "  - DOMAIN-SUFFIX,nflxvideo.net,Netflix",
    "  - DOMAIN-SUFFIX,netflix.net,Netflix",
    "  - DOMAIN-SUFFIX,youtube.com,YouTube",
    "  - DOMAIN-SUFFIX,googlevideo.com,YouTube",
    "  - DOMAIN-SUFFIX,ytimg.com,YouTube",
    "  - DOMAIN-SUFFIX,telegram.org,Telegram",
    "  - DOMAIN-SUFFIX,t.me,Telegram",
    "  - DOMAIN-SUFFIX,openai.com,OpenAI",
    "  - DOMAIN-SUFFIX,chat.openai.com,OpenAI",
    "  - DOMAIN-SUFFIX,github.com,国外流量",
    "  - DOMAIN-SUFFIX,githubusercontent.com,国外流量",
    "  - DOMAIN-SUFFIX,twitter.com,国外流量",
    "  - DOMAIN-SUFFIX,facebook.com,国外流量",
    "  - DOMAIN-SUFFIX,instagram.com,国外流量",
    "  - DOMAIN-SUFFIX,google.com,国外流量",
    "  - DOMAIN-SUFFIX,gstatic.com,国外流量",
    // 国内直连
    "  - GEOIP,CN,国内流量",
    "  - MATCH,自动选择"
  ].join("\n");
}

async function refreshIPs(env) {
  const ips = await fetchIPs();
  await env.OPENCLASH_KV.put(KV_KEY, JSON.stringify(ips));
}

export default {
  async fetch(request, env, ctx) {
    try {
      const pathname = new URL(request.url).pathname;
      if (
        pathname === "/" ||
        pathname === "/sub" ||
        pathname === "/clash"
      ) {
        let ipJson = await env.OPENCLASH_KV.get(KV_KEY);
        let ips;
        if (!ipJson) {
          ips = await fetchIPs();
          ctx.waitUntil(env.OPENCLASH_KV.put(KV_KEY, JSON.stringify(ips)));
        } else {
          ips = JSON.parse(ipJson);
        }
        const nodes = genClashNodes(ips);
        const config = genClashConfig(nodes);
        return new Response(config, {
          headers: { "content-type": "text/yaml; charset=utf-8" }
        });
      }
      if (pathname === "/ping") {
        return new Response("ok", { headers: { "content-type": "text/plain" } });
      }
      return new Response("Not found", { status: 404 });
    } catch (e) {
      return new Response(`Worker Exception: ${e && e.stack ? e.stack : e}`, {
        status: 500,
        headers: { "content-type": "text/plain; charset=utf-8" }
      });
    }
  },
  async scheduled(event, env, ctx) {
    try {
      await refreshIPs(env);
    } catch (e) {}
  }
};
